package netmon

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"log"
	"net"
	"structs"
	"time"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
)

func IncomingPacketsPerSecond(ifname string, seconds_span int) (float32, error) {
	// load the compiled eBPF ELF into the kernel.
	var objs netmonObjects
	if err := loadNetmonObjects(&objs, nil); err != nil {
		return 0, fmt.Errorf("loading eBPF objects: %w", err)
	}
	defer func(objs *netmonObjects) {
		err := objs.Close()
		if err != nil {
			log.Printf("closing netmon objects: %v", err)
		}
	}(&objs)

	iface, err := net.InterfaceByName(ifname)
	if err != nil {
		return 0, fmt.Errorf("getting interface %s: %w", ifname, err)
	}

	// attach count_packets to the network interface.
	xlink, err := link.AttachXDP(link.XDPOptions{
		Program:   objs.CountPackets,
		Interface: iface.Index,
	})
	if err != nil {
		return 0, fmt.Errorf("AttachXDP: %w", err)
	}
	defer func(xlink link.Link) {
		err := xlink.Close()
		if err != nil {
			log.Printf("closing xdp link: %v", err)
		}
	}(xlink)

	log.Printf("Counting incoming packets on %s..", ifname)


	// check counter after deisgnated timespan
	// 1s = 1_000_000_000ns
	time.Sleep(time.Duration(seconds_span * 1_000_000_000))

	var count uint64
	err = objs.PktCount.Lookup(uint32(0), &count)
	if err != nil {
		log.Fatal("Map lookup:", err)
	}

	return float32(count) / float32(seconds_span), nil
}

type bpfEvent struct {
	_     structs.HostLayout
	Comm  [16]uint8
	Sport uint16
	Dport uint16
	Saddr uint32
	Daddr uint32
}

func MonitorTcpConnections() (bpfEvent, error) {
	// allow the current process to lock memory for eBPF resources.
	if err := rlimit.RemoveMemlock(); err != nil {
		log.Fatal(err)
	}

	objs := netmonObjects{}
	if err := loadNetmonObjects(&objs, nil); err != nil {
		log.Fatalf("loading objects: %v", err)
	}
	defer objs.Close()

	l, err := link.AttachTracing(link.TracingOptions{
		Program: objs.TcpConnect,
	})
	if err != nil {
		log.Fatal(err)
	}
	defer l.Close()

	rd, err := ringbuf.NewReader(objs.Events)
	if err != nil {
		log.Fatalf("opening ringbuf reader: %s", err)
	}
	defer rd.Close()

	log.Printf("%-16s %-15s %-6s -> %-15s %-6s",
		"Comm",
		"Src addr",
		"Port",
		"Dest addr",
		"Port",
	)

	// bpfEvent is generated by bpf2go.
	var event bpfEvent
	for {
		record, err := rd.Read()
		if err != nil {
			if errors.Is(err, ringbuf.ErrClosed) {
				log.Println("received signal, exiting..")
				return bpfEvent{}, err
			}
			log.Printf("reading from reader: %s", err)
			continue
		}

		// Parse the ringbuf event entry into a bpfEvent structure.
		if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.BigEndian, &event); err != nil {
			log.Printf("parsing ringbuf event: %s", err)
			continue
		}

		return event, nil
	}
}
